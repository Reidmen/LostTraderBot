/*
    Event class
    
    This file implements an event-driven architecture commonly used in algorithmic trading systems
    as described in works like "Successful Algorithmic Trading".
        
    The event-driven approach decouples system components (data handlers, strategy, portfolio,
    execution) by having them communicate through events, creating a more maintainable and
    extensible system.
*/
#pragma once
#include <iostream>
#include <string>

// Define event types
// These represent the core event types in a typical algorithmic trading system:
// - MARKET: New market data available
// - SIGNAL: Strategy generated a trading signal
// - ORDER: Portfolio decided to place an order
// - FILL: Order was executed in the market
enum EventType {
   MARKET = 0,
   SIGNAL = 1,
   ORDER = 2,
   FILL = 3
};

// Base Event class that all specific event types inherit from
class Event {
   public:
      EventType type;  // Identifies the specific type of event
      std::string target;  // Component that should handle this event
      virtual ~Event() = default;  // Virtual destructor for proper polymorphic cleanup
};

// MarketEvent: Generated when new market data is available
class MarketEvent : public Event {
   public:
    MarketEvent() { this->type = EventType::MARKET; }
};

// SignalEvent: Generated by a strategy when it identifies a trading opportunity
// Contains the symbol to trade, timestamp, and a signal value indicating trade direction/strength
class SignalEvent : public Event {
   public:
    std::string symbol;     // The financial instrument to trade
    long long timestamp;    // When the signal was generated
    double signal;          // Signal value (positive for long, negative for short)

    SignalEvent(std::string* symbol, long long* timestamp, double signal, std::string target) {
      this->type = EventType::SIGNAL;
      this->symbol = *symbol;
      this->timestamp = *timestamp;
      this->signal = signal;
      this->target = target;
    };
};

// OrderEvent: Generated by portfolio when it decides to place an order
// Contains details needed to execute a trade in the market
// Following "Trading Systems" by Tomasini & Jaekle, orders should specify
// instrument, type, quantity and direction at minimum
class OrderEvent : public Event {
   public:
    std::string symbol;     // The financial instrument to trade
    std::string order_type; // Market, limit, stop, etc.
    double quantity;        // Amount to trade
    std::string direction;  // "BUY" or "SELL"

    OrderEvent(std::string* symbol, std::string* order_type, double* quantity,
               std::string* direction, std::string target) {
      this->type = EventType::ORDER;
      this->symbol = *symbol;
      this->order_type = *order_type;
      this->quantity = *quantity;
      this->direction = *direction;
      this->target = target;
    };

    void logOrder() { std::cout << "Order placed!" << std::endl; }
};

// FillEvent: Generated when an order is executed in the market
// Contains execution details including transaction costs
class FillEvent : public Event {
   public:
    std::string symbol;     // The financial instrument that was traded
    long long timestamp;    // When the fill occurred
    double quantity;        // Amount that was traded
    std::string direction;  // "BUY" or "SELL"
    double cost;            // Total cost of the transaction
    double commission;      // Fee paid to broker
    double slippage;        // Difference between expected and actual execution price

    FillEvent(std::string* symbol, long long* timestamp, double* quantity,
              std::string direction, double cost, std::string target) {
      this->type = EventType::FILL;
      this->symbol = *symbol;
      this->timestamp = *timestamp;
      this->quantity = *quantity;
      this->direction = direction;
      this->cost = cost;
      this->commission = computeCommission();
      this->slippage = computeSlippage();
      this->target = target;
    };

    // Simple commission model based on percentage of trade value
    double computeCommission() { return 0.001 * cost; }
    
    // Currently returns zero slippage - in real systems this would model market impact
    // NOTE: "Algorithmic Trading and DMA" by Barry Johnson discusses various slippage models
    double computeSlippage() { return 0.0; }
};
